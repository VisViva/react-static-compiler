/**
 * Libraries
 */

import fs from 'fs';
import path from 'path';
import React from 'react';
import { Provider } from 'react-redux';
import { renderToString } from 'react-dom/server';
import Promise from 'bluebird';

/**
 * Utilities
 */

import {
    getExtraneousAssets,
    compileAsset,
    deleteFolderRecursively,
    functionName,
    stripComponentWrappers,
    assembleComponentTree,
    assembleAssets,
    injectResources,
    assembleNestedComponent,
    assembleNestedComponentAsJsxString,
    ensureDirectoryExistence,
    log,
    warning,
    error,
    success
} from './helpers.js';

/**
 * Static compiler plugin
 */

function ReactStaticCompiler(options) {

    /**
     * Plugin options
     */

    this.options = options;

    /**
     * Template string
     */

    this.template;

    /**
     * Store
     */

    this.store;

    /**
     * Assembled assets
     */

    this.assets;
}

/**
 * Entry point
 */

ReactStaticCompiler.prototype.apply = function(compiler) {
    let compilationPromise;

    /**
     * Webpack make endpoint
     */

    compiler.plugin('make', (compilation, callback) => {

        /**
         * Retrieving options
         */

        const { store, routes, template } = this.options;

        /**
         * Load assets
         */

        const promises = [
            compileAsset({
                filepath: store,
                outputFilename: 'store.js',
                compilation,
                context: compiler.context,
                template: this.template
            }),
            compileAsset({
                filepath: routes,
                outputFilename: 'routes.js',
                compilation,
                context: compiler.context,
                template: this.template
            }),
            compileAsset({
                filepath: template,
                outputFilename: 'index.html',
                compilation,
                context: compiler.context,
                template: this.template
            })
        ];

        /**
         * Continue
         */

        compilationPromise = Promise.all(promises)
            .catch(error => Promise.reject(new Error(error)))
            .finally(callback);
    });

    /**
     * Webpack emit endpoint
     */

    compiler.plugin('emit', (compilation, callback) => {

        /**
         * Retrieving options
         */

        const { root, index, trash, nesting } = this.options;

        /**
         * Continue
         */

        compilationPromise
            .catch(callback)
            .then(assets => {

                /**
                 * Remove extraneous assets generated by webpack loaders
                 */

                log(`Removing original entry point asset and associated sourcemap. Asset name: "app-${compilation.hash}.js"`);
                delete compilation.assets[`app-${compilation.hash}.js`];
                delete compilation.assets[`app-${compilation.hash}.js.map`];
                getExtraneousAssets().forEach(key => {
                    log(`Removing extraneous asset and associated sourcemap. Asset name: "${key}"`);
                    delete compilation.assets[key];
                    delete compilation.assets[key + '.map'];
                });
                success(`Removing extraneous assets successfully`);

                /**
                 * Extract plugin related data gathered from plugin options
                 */

                let [store, routes, template] = assets;
                routes = routes.routes || routes.default || routes;
                this.store = store.store || store.default || store;
                this.template = template.template || template.default || template;

                /**
                 * Create tree of components to be rendered statically
                 */

                this.assets = assembleAssets(assembleComponentTree(routes));
                this.assets.map(asset => {

                    /** 
                     * Create source files 
                     */

                    const components = asset.components
                        .map(asset => stripComponentWrappers(asset.displayName && asset.displayName || functionName(asset)))
                        .reduce((accumulator, value) => value + ', ' + accumulator);
                    const jsxString = assembleNestedComponentAsJsxString(asset.components);

                    /** 
                     * Check if the route is supposed to be index
                     */

                    const name = asset.path.split('/').pop().split('.').shift();
                    if (name === index) {
                        warning(`Renaming ${name} to Index`);
                        asset.path = asset.path.replace(name, 'Index');
                        asset.name = 'index';
                    } else {
                        asset.name = name.toLowerCase();
                    }

                    const filePath = `${trash}/${asset.name}.js`;
                    ensureDirectoryExistence(filePath);
                    const file = `
                        import 'rxjs';
                        import React from 'react';
                        import ReactDOM from 'react-dom';
                        import { Provider } from 'react-redux';
                        import store from '../source/store';
                        import '../source/static/styles/main.scss';
                        import { ${components} } from '../source/containers';
                        ReactDOM.render(
                            <Provider store={store}>
                                ${jsxString}
                            </Provider>,
                            document.getElementById('${root}')
                        );
                        `;
                    warning(file);
                    fs.writeFileSync(path.resolve(filePath), file);
                });
            })
            .then(() => {

                /** 
                 * Load assets 
                 */
                const promises = this.assets.map(asset => {
                    return compileAsset({
                        filepath: path.resolve(`${trash}/${asset.name}.js`),
                        outputFilename: `${asset.name}-${compilation.hash}.js`,
                        compilation,
                        context: compiler.context,
                        template: this.template
                    });
                });

                return Promise.all(promises);
            })
            .then((assets) => {
                /**
                 * Delete trash folder
                 */

                deleteFolderRecursively(path.resolve(trash));

                /**
                 * Produces compiled assets
                 */

                this.assets.map(asset => {

                    /**
                     * Render react markup
                     */

                    const markup = renderToString(<Provider store={this.store}>{assembleNestedComponent(asset.components)}</Provider>);

                    /**
                     * Inject resources
                     */

                    const prefix = asset.components
                        .map((value, index) => index > nesting && '../' || '')
                        .reduce((accumulator, value) => value + accumulator);
                    const postfix = compilation.hash;
                    const html = injectResources(this.template, prefix, postfix, markup, asset.name);

                    /**
                     * Render compiled asset
                     */

                    compilation.assets[
                        asset.path
                        .toLowerCase()
                        .split('/')
                        .slice(nesting + 1)
                        .join('/')
                    ] = {
                        source: () => html,
                        size: () => html.length
                    };
                });
            })
            .finally(callback);
    });
};

module.exports = ReactStaticCompiler;
